package net.imglib2.roi.geom.integer;

import java.util.Iterator;

import net.imglib2.Cursor;
import net.imglib2.IterableInterval;
import net.imglib2.Localizable;
import net.imglib2.Point;
import net.imglib2.Positionable;
import net.imglib2.RealPoint;
import net.imglib2.RealPositionable;
import net.imglib2.Sampler;

/**
 * An immutable line sampled on integer position.
 * <p>
 * The cursors generated by the {@link IterableInterval} will iterate exactly
 * once over all the integer locations on a line between in proper order from
 * the specified start to the specified end points, included.
 * <p>
 * Two lines are considered equal iff their starting points and ending points
 * are at to the same locations. This is reflected in the
 * {@link #equals(Object)}, {@link #hashCode()} and {@link #iterationOrder()}
 * methods.
 * <p>
 * This implementation uses floating-point logic instead of the pure integer
 * logic of Bresenham line (<a href=
 * "https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Wikipedia</a>)
 * but the results are quasi identical and the performance penalty small.
 * 
 * @author Jean-Yves Tinevez
 *
 */
public class IterableLine implements IterableInterval< Void >
{

	/**
	 * N dimensions.
	 */
	private final int n;

	/**
	 * Number of points this line will be sampled on.
	 */
	private final long nPoints;

	/**
	 * The starting point of the line.
	 */
	private final Localizable start;

	/**
	 * End point of the line.
	 */
	private final Localizable end;

	/**
	 * Instantiates a new line that goes from start to end points.
	 * 
	 * @param start
	 *            the location of the start point.
	 * @param end
	 *            the location of the end point.
	 */
	public IterableLine( final Localizable start, final Localizable end )
	{
		this.start = new Point( start );
		this.end = new Point( end );
		this.n = start.numDimensions();

		final Point diff = new Point( n );
		long maxDiff = -1;
		for ( int d = 0; d < n; d++ )
		{
			final long dx = end.getLongPosition( d ) - start.getLongPosition( d );
			diff.setPosition( dx, d );
			if ( Math.abs( dx ) > maxDiff )
				maxDiff = Math.abs( dx );
		}
		this.nPoints = maxDiff;
	}

	@Override
	public boolean equals( final Object o )
	{
		if ( o == this ) { return true; }
		if ( !( o instanceof IterableLine ) ) { return false; }
		final IterableLine ol = ( IterableLine ) o;
		return locationsEqual( start, ol.start ) && locationsEqual( end, ol.end );
	}

	@Override
	public int hashCode()
	{
		int hash = 17;
		hash = 31 * hash + hash( start );
		hash = 31 * hash + hash( end );
		return hash;
	}

	@Override
	public long size()
	{
		return nPoints;
	}

	@Override
	public Void firstElement()
	{
		return cursor().next();
	}

	@Override
	public Object iterationOrder()
	{
		return this;
	}

	@Override
	public double realMin( final int d )
	{
		return min( d );
	}

	@Override
	public void realMin( final double[] min )
	{
		for ( int d = 0; d < n; d++ )
			min[ d ] = realMin( d );
	}

	@Override
	public void realMin( final RealPositionable min )
	{
		for ( int d = 0; d < n; d++ )
			min.setPosition( realMin( d ), d );
	}

	@Override
	public double realMax( final int d )
	{
		return max( d );
	}

	@Override
	public void realMax( final double[] max )
	{
		for ( int d = 0; d < n; d++ )
			max[ d ] = realMax( d );
	}

	@Override
	public void realMax( final RealPositionable max )
	{
		for ( int d = 0; d < n; d++ )
			max.setPosition( realMax( d ), d );
	}

	@Override
	public int numDimensions()
	{
		return n;
	}

	@Override
	public Iterator< Void > iterator()
	{
		return cursor();
	}

	@Override
	public long min( final int d )
	{
		return Math.min( start.getLongPosition( d ), end.getLongPosition( d ) );
	}

	@Override
	public void min( final long[] min )
	{
		for ( int d = 0; d < n; d++ )
			min[ d ] = min( d );
	}

	@Override
	public void min( final Positionable min )
	{
		for ( int d = 0; d < n; d++ )
			min.setPosition( min( d ), d );
	}

	@Override
	public long max( final int d )
	{
		return Math.max( start.getLongPosition( d ), end.getLongPosition( d ) );
	}

	@Override
	public void max( final long[] max )
	{
		for ( int d = 0; d < n; d++ )
			max[ d ] = max( d );
	}

	@Override
	public void max( final Positionable max )
	{
		for ( int d = 0; d < n; d++ )
			max.setPosition( max( d ), d );
	}

	@Override
	public void dimensions( final long[] dimensions )
	{
		for ( int d = 0; d < n; d++ )
			dimensions[ d ] = max( d ) - min( d );
	}

	@Override
	public long dimension( final int d )
	{
		return max( d ) - min( d );
	}

	@Override
	public Cursor< Void > cursor()
	{
		return localizingCursor();
	}

	@Override
	public Cursor< Void > localizingCursor()
	{
		return new LineCursor();
	}

	private final class LineCursor implements Cursor< Void >
	{

		private final RealPoint increment;

		private final RealPoint current;

		private long index;
		

		public LineCursor()
		{
			this.current = new RealPoint( n );

			final Point diff = new Point( n );
			long maxDiff = -1;
			for ( int d = 0; d < n; d++ )
			{
				final long dx = end.getLongPosition( d ) - start.getLongPosition( d );
				diff.setPosition( dx, d );
				if ( Math.abs( dx ) > maxDiff )
					maxDiff = Math.abs( dx );
			}

			this.increment = new RealPoint( n );
			if (maxDiff != 0)
				for ( int d = 0; d < n; d++ )
					increment.setPosition( diff.getDoublePosition( d ) / maxDiff, d );

			reset();
		}

		public LineCursor( final LineCursor c )
		{
			this();
			index = c.index;
			current.setPosition( c );
		}

		@Override
		public boolean hasNext()
		{
			return index < nPoints;
		}

		@Override
		public Void get()
		{
			return null;
		}

		@Override
		public void fwd()
		{
			index++;
			for ( int d = 0; d < n; d++ )
				current.move( increment.getDoublePosition( d ), d );
		}

		@Override
		public void jumpFwd( final long steps )
		{
			if ( steps < 0 || steps > nPoints )
				throw new IllegalArgumentException( "Cannot jump by " + steps + " points." );

			index += steps;
			for ( int d = 0; d < n; d++ )
				current.move( steps * increment.getDoublePosition( d ), d );
		}

		@Override
		public void reset()
		{
			index = -1;
			current.setPosition( start );
			for ( int d = 0; d < n; d++ )
				current.move( - increment.getDoublePosition( d ), d );
		}

		@Override
		public Void next()
		{
			fwd();
			return null;
		}

		@Override
		public void localize( final long[] position )
		{
			for ( int d = 0; d < n; d++ )
				position[ d ] = getLongPosition( d );
		}

		@Override
		public long getLongPosition( final int d )
		{
			return Math.round( current.getDoublePosition( d ) );
		}

		@Override
		public void localize( final int[] position )
		{
			for ( int d = 0; d < n; d++ )
				position[ d ] = getIntPosition( d );
		}

		@Override
		public int getIntPosition( final int d )
		{
			return ( int ) getLongPosition( d );
		}

		@Override
		public Sampler< Void > copy()
		{
			return new LineCursor( this );
		}

		@Override
		public Cursor< Void > copyCursor()
		{
			return new LineCursor();
		}

		@Override
		public void localize( final float[] position )
		{
			for ( int d = 0; d < position.length; d++ )
				position[d] = getLongPosition( d );
		}

		@Override
		public void localize( final double[] position )
		{
			for ( int d = 0; d < position.length; d++ )
				position[d] = getLongPosition( d );
		}

		@Override
		public float getFloatPosition( final int d )
		{
			return Math.round( current.getFloatPosition( d ) );
		}

		@Override
		public double getDoublePosition( final int d )
		{
			return Math.round( current.getFloatPosition( d ) );
		}

		@Override
		public int numDimensions()
		{
			return current.numDimensions();
		}
	}

	// TODO: Replace by the method in net.imglib2.util.Util when the version is
	// released.
	private static final boolean locationsEqual( final Localizable l1, final Localizable l2 )
	{
		final int numDims = l1.numDimensions();
		if ( l2.numDimensions() != numDims )
			return false;
		for ( int d = 0; d < numDims; d++ )
		{
			if ( l1.getLongPosition( d ) != l2.getLongPosition( d ) )
				return false;
		}
		return true;
	}

	private static final int hash( final Localizable l )
	{
		int hash = 17;
		for ( int d = 0; d < l.numDimensions(); d++ )
			hash = 31 * hash + Long.hashCode( l.getLongPosition( d ) );
		return hash;
	}
}
