/*
 * #%L
 * ImgLib2: a general-purpose, multidimensional image processing library.
 * %%
 * Copyright (C) 2009 - 2016 Tobias Pietzsch, Stephan Preibisch, Stephan Saalfeld,
 * John Bogovic, Albert Cardona, Barry DeZonia, Christian Dietz, Jan Funke,
 * Aivar Grislis, Jonathan Hale, Grant Harris, Stefan Helfrich, Mark Hiner,
 * Martin Horn, Steffen Jaensch, Lee Kamentsky, Larry Lindsey, Melissa Linkert,
 * Mark Longair, Brian Northan, Nick Perry, Curtis Rueden, Johannes Schindelin,
 * Jean-Yves Tinevez and Michael Zinsmaier.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */

package net.imglib2.roi.mask;

import java.util.List;

import net.imglib2.Interval;
import net.imglib2.Localizable;
import net.imglib2.RealInterval;
import net.imglib2.RealLocalizable;
import net.imglib2.RealRandomAccess;
import net.imglib2.realtransform.AffineGet;
import net.imglib2.roi.mask.integer.MaskInterval;
import net.imglib2.roi.mask.real.MaskRealInterval;

/**
 * Utility class for working with {@link Mask}s.
 *
 * @author Curtis Rueden
 * @author Alison Walter
 */
public final class Masks
{

	private Masks()
	{
		// NB: Prevent instantiation of utility class.
	}

	// -- AFFINE TRANSFORM --

	/**
	 * See a {@link Mask} as transformed by an {@link AffineGet}. The
	 * {@link AffineGet} is interpreted according to the natural understanding
	 * that the source is transformed by it. E.g. a positive translation of
	 * dimension <em>x</em> would shift the source to the right. Therefore, the
	 * samples need to be generated by the inverse of the {@link AffineGet}.
	 * Here, the {@link AffineGet} is inverted using it's
	 * {@link AffineGet#inverse()} method that is expected to generate an
	 * inverse that changes with the original transformation accordingly. That
	 * way, changing the state of the {@link AffineGet} will immediately change
	 * the state of any new {@link RealRandomAccess} generated by the view.
	 *
	 * <p>
	 * If the given {@link Mask} is a {@link MaskRealInterval}, a
	 * {@link MaskRealInterval} will be returned.
	 * </p>
	 *
	 * @param operand
	 *            the {@link Mask} to be transformed
	 * @param transformFromSource
	 *            the {@link AffineGet} transforming source coordinates to
	 *            coordinates of the returned {@link Mask}
	 *
	 * @return real space Mask representing the transformed source
	 */
	public static Mask< RealLocalizable > affineTransform( final Mask< RealLocalizable > operand, final AffineGet transformFromSource )
	{
		if ( operand instanceof MaskRealInterval )
			return BinaryOperations.intervalTransform( operand.numDimensions() ).apply( ( MaskRealInterval ) operand, transformFromSource.inverse() );
		return BinaryOperations.transform( operand.numDimensions() ).apply( operand, transformFromSource.inverse() );
	}

	// -- AND --

	/**
	 * Creates a discrete space {@link Mask} which is the intersection of the
	 * provided {@link Mask}s. This may result in a Mask which contains never
	 * returns {@code true}.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a Mask which is the intersection of the two
	 */
	public static Mask< Localizable > and( final Mask< Localizable > leftOperand, final Mask< Localizable > rightOperand )
	{
		if ( leftOperand instanceof MaskInterval && rightOperand instanceof MaskInterval )
		{
			final MaskInterval l = ( MaskInterval ) leftOperand;
			final MaskInterval r = ( MaskInterval ) rightOperand;
			if ( isAndEmpty( l, r ) )
				return new EmptyMask<>( leftOperand.numDimensions() );
			return BinaryOperations.intervalAnd().apply( l, r );
		}
		return BinaryOperations.and().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates a real space {@link Mask} which is the intersection of the
	 * provided {@link Mask}s. If both Masks know their bounds, then the
	 * resulting Mask will also know its bounds.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a Mask which is the intersection of the two
	 */
	public static Mask< RealLocalizable > realAnd( final Mask< RealLocalizable > leftOperand, final Mask< RealLocalizable > rightOperand )
	{
		if ( leftOperand instanceof MaskRealInterval && rightOperand instanceof MaskRealInterval )
		{
			final MaskRealInterval l = ( MaskRealInterval ) leftOperand;
			final MaskRealInterval r = ( MaskRealInterval ) rightOperand;
			if ( isAndEmpty( l, r ) )
				return new EmptyMask<>( leftOperand.numDimensions() );
			return BinaryOperations.realIntervalAnd().apply( l, r );
		}
		return BinaryOperations.realAnd().apply( leftOperand, rightOperand );
	}

	// -- NOT --

	/**
	 * Creates a discrete space {@link Mask} which is the NOT of the provided
	 * mask.
	 *
	 * @param operand
	 *            the mask to be NOT-ed
	 * @return the NOT of the original Mask, the result does not know its bounds
	 */
	public static Mask< Localizable > not( final Mask< Localizable > operand )
	{
		return UnaryOperations.not().apply( operand );
	}

	/**
	 * Creates a real space {@link Mask} which is the NOT of the provided mask.
	 *
	 * @param operand
	 *            the mask to be NOT-ed
	 * @return the NOT of the original Mask, the result does not know its bounds
	 */
	public static Mask< RealLocalizable > realNot( final Mask< RealLocalizable > operand )
	{
		return UnaryOperations.realNot().apply( operand );
	}

	// -- OR --

	/**
	 * Creates a discrete space {@link Mask} which is the union of the two
	 * provided Masks. If the two Masks are {@link Interval}s, then the
	 * resulting Mask will also be an {@link Interval}.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a Mask which is the union of the left and right operands
	 */
	public static Mask< Localizable > or( final Mask< Localizable > leftOperand, final Mask< Localizable > rightOperand )
	{
		if ( leftOperand instanceof MaskInterval && rightOperand instanceof MaskInterval )
			return intervalOr( ( MaskInterval ) leftOperand, ( MaskInterval ) rightOperand );
		return BinaryOperations.or().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates a discrete space {@link Mask} which is the union of all the masks
	 * in the provided list. If all Masks in the list are {@link Interval}s, the
	 * resulting Mask is also an Interval.
	 *
	 * @param operands
	 *            A list of {@link Mask}s to be union-d
	 * @return a Mask which is the union of all Masks in the list
	 */
	@SuppressWarnings( "unchecked" )
	public static < M extends Mask< Localizable > > M or( final List< M > operands )
	{
		for ( int i = 0; i < operands.size(); i++ )
		{
			if ( !( operands.get( i ) instanceof MaskInterval ) )
				return ( M ) NaryOperations.or().apply( ( List< Mask< Localizable > > ) operands );
		}
		return ( M ) intervalOr( ( List< MaskInterval > ) operands );
	}

	/**
	 * Creates a {@link MaskInterval} by union-ing the left and right operand.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a MaskInterval which is the union of the left and right operands
	 */
	public static MaskInterval intervalOr( final MaskInterval leftOperand, final MaskInterval rightOperand )
	{
		return BinaryOperations.intervalOr().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates {@link MaskInterval} which is the union of all
	 * {@link MaskInterval}s in the list.
	 *
	 * @param operands
	 *            A list of {@link Mask}s to be union-d
	 * @return a Mask which is the union of all Masks in the list
	 */
	public static MaskInterval intervalOr( final List< MaskInterval > operands )
	{
		return NaryOperations.intervalOr().apply( operands );
	}

	/**
	 * Creates a real space {@link Mask} which is the union of the two provided
	 * Masks. If the two Masks are {@link RealInterval}s, then the resulting
	 * Mask will also be a {@link RealInterval}.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a Mask which is the union of the left and right operands
	 */
	public static Mask< RealLocalizable > realOr( final Mask< RealLocalizable > leftOperand, final Mask< RealLocalizable > rightOperand )
	{
		if ( leftOperand instanceof MaskRealInterval && rightOperand instanceof MaskRealInterval )
			return realIntervalOr( ( MaskRealInterval ) leftOperand, ( MaskRealInterval ) rightOperand );
		return BinaryOperations.realOr().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates a real space {@link Mask} which is the union of all the masks in
	 * the provided list. If all Masks in the list are {@link RealInterval}s,
	 * the resulting Mask is also a RealInterval.
	 *
	 * @param operands
	 *            A list of {@link Mask}s to be union-d
	 * @return a Mask which is the union of all Masks in the list
	 */
	@SuppressWarnings( "unchecked" )
	public static < M extends Mask< RealLocalizable > > M realOr( final List< M > operands )
	{
		for ( int i = 0; i < operands.size(); i++ )
		{
			if ( !( operands.get( i ) instanceof MaskRealInterval ) )
				return ( M ) NaryOperations.realOr().apply( ( List< Mask< RealLocalizable > > ) operands );
		}
		return ( M ) realIntervalOr( ( List< MaskRealInterval > ) operands );
	}

	/**
	 * Creates a {@link MaskRealInterval} by union-ing the left and right
	 * operand.
	 *
	 * @param leftOperand
	 *            the left operand
	 * @param rightOperand
	 *            the right operand
	 * @return a Mask which is the union of the left and right operands
	 */
	public static MaskRealInterval realIntervalOr( final MaskRealInterval leftOperand, final MaskRealInterval rightOperand )
	{
		return BinaryOperations.realIntervalOr().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates {@link MaskRealInterval} which is the union of all
	 * {@link MaskRealInterval}s in the list.
	 *
	 * @param operands
	 *            A list of {@link Mask}s to be union-d
	 * @return a Mask which is the union of all Masks in the list
	 */
	public static MaskRealInterval realIntervalOr( final List< MaskRealInterval > operands )
	{
		return NaryOperations.realIntervalOr().apply( operands );
	}

	// -- SUBTRACT --

	/**
	 * Creates a discrete space {@link Mask} which is the result of subtracting
	 * the right operand from the left operand. Subtraction, in this case, is
	 * defined as {@code leftOperand && !rightOperand}. If both operands are
	 * {@link MaskInterval}s, a {@link MaskInterval} will be returned.
	 *
	 * @param leftOperand
	 *            the left operand in the subtraction, and the first variable
	 *            passed to the method
	 * @param rightOperand
	 *            the right operand in the subtraction, and the second variable
	 *            passed to the method
	 * @return a Mask which contains the rightOperand subtracted from the
	 *         leftOperand
	 */
	public static Mask< Localizable > subtract( final Mask< Localizable > leftOperand, final Mask< Localizable > rightOperand )
	{
		if ( leftOperand instanceof MaskInterval && rightOperand instanceof MaskInterval )
			return BinaryOperations.intervalSubtract().apply( ( MaskInterval ) leftOperand, ( MaskInterval ) rightOperand );
		return BinaryOperations.subtract().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates a real space {@link Mask} which is the result of subtracting the
	 * right operand from the left operand. Subtraction, in this case, is
	 * defined as {@code leftOperand && !rightOperand}. If both operands are
	 * {@link MaskRealInterval}s, a {@link MaskRealInterval} will be returned.
	 *
	 * @param leftOperand
	 *            the left operand in the subtraction, and the first variable
	 *            passed to the method
	 * @param rightOperand
	 *            the right operand in the subtraction, and the second variable
	 *            passed to the method
	 * @return a Mask which contains the rightOperand subtracted from the
	 *         leftOperand
	 */
	public static Mask< RealLocalizable > realSubtract( final Mask< RealLocalizable > leftOperand, final Mask< RealLocalizable > rightOperand )
	{
		if ( leftOperand instanceof MaskRealInterval && rightOperand instanceof MaskRealInterval )
			return BinaryOperations.realIntervalSubtract().apply( ( MaskRealInterval ) leftOperand, ( MaskRealInterval ) rightOperand );
		return BinaryOperations.realSubtract().apply( leftOperand, rightOperand );
	}

	// -- XOR --

	/**
	 * Creates a discrete space {@link Mask} which is an exclusive or of the two
	 * provided masks. If both masks are {@link Interval}s, the resulting mask
	 * will also be an {@link Interval}.
	 *
	 * <p>
	 * This method does not guarantee that the resulting mask returns
	 * {@code true} for any location.
	 * </p>
	 *
	 * @param leftOperand
	 *            a discrete space Mask
	 * @param rightOperand
	 *            a discrete space Mask
	 * @return A discrete space Mask which is the exclusive or of the two masks
	 */
	public static Mask< Localizable > xor( final Mask< Localizable > leftOperand, final Mask< Localizable > rightOperand )
	{
		if ( leftOperand instanceof MaskInterval && rightOperand instanceof MaskInterval )
			return BinaryOperations.intervalXor().apply( ( MaskInterval ) leftOperand, ( MaskInterval ) rightOperand );
		return BinaryOperations.xor().apply( leftOperand, rightOperand );
	}

	/**
	 * Creates a real space {@link Mask} which is the exclusive or of the two
	 * provided masks. If both of the provided masks are {@link RealInterval}s,
	 * a {@link RealInterval} will be returned.
	 *
	 * <p>
	 * This method does not guarantee that the resulting mask returns
	 * {@code true} for any location.
	 * </p>
	 *
	 * @param leftOperand
	 *            a real space Mask
	 * @param rightOperand
	 *            a real space Mask
	 * @return A real space mask which is the exclusive or of the right and left
	 *         operands.
	 */
	public static Mask< RealLocalizable > realXor( final Mask< RealLocalizable > leftOperand, final Mask< RealLocalizable > rightOperand )
	{
		if ( leftOperand instanceof MaskRealInterval && rightOperand instanceof MaskRealInterval )
			return BinaryOperations.realIntervalXor().apply( ( MaskRealInterval ) leftOperand, ( MaskRealInterval ) rightOperand );
		return BinaryOperations.realXor().apply( leftOperand, rightOperand );
	}

	// -- Helper Methods --

	/**
	 * Checks if the intersection of two {@link MaskIntervals} is empty.
	 *
	 * @param left
	 *            left operand
	 * @param right
	 *            right operand
	 * @return true if empty, false otherwise
	 */
	private static boolean isAndEmpty( final MaskInterval left, final MaskInterval right )
	{
		for ( int d = 0; d < left.numDimensions(); d++ )
		{
			if ( left.min( d ) > right.max( d ) || left.max( d ) < right.min( d ) )
				return true;
		}
		return false;
	}

	/**
	 * Checks if the intersection of two {@link MaskRealIntervals} is empty.
	 *
	 * @param left
	 *            left operand
	 * @param right
	 *            right operand
	 * @return true if empty, false otherwise
	 */
	private static boolean isAndEmpty( final MaskRealInterval left, final MaskRealInterval right )
	{
		for ( int d = 0; d < left.numDimensions(); d++ )
		{
			if ( left.realMin( d ) > right.realMax( d ) || left.realMax( d ) < right.realMin( d ) )
				return true;
		}
		return false;
	}
}
